--
-- extract.lua - Extracts VB6 declares and generates VB6 stub implementations from C/C++ source
--
-- Usage:
--        C:> luajit.exe extract.lua [dll_def_file] [vb_module_name]
--
-- Tries to map C/C++ types to VB6 types and outputs warnings when no known mapping is found
--
local re = require('re')

local DEBUG_DLL_FILE = "debug_sqlite3.dll"
local DEBUG_API_PREFIX = "sqlite3_"
local VB_API_PREFIX = "vbsqlite3_"
--- command-line arguments defaults
local DEFAULT_ARG1 = "debug_sqlite3.def"
local DEFAULT_ARG2 = "mdSqlite"

local function readfile(name)
  local f = io.open(name, "rb")
  local ret = f:read("*all")
  f:close()
  return ret
end

local mapvbtype = {
    ["char *"] = "Long",
    ["const char *"] = "Long",
    ["double"] = "Double",
    ["sqlite3_int64"] = "Currency",
    ["sqlite_int64"] = "Currency",
    ["sqlite3_uint64"] = "Currency",
    ["i64"] = "Currency",
    ["u64"] = "Currency",
    ["int"] = "Long",
    ["unsigned int"] = "Long",
    ["void"] = "Long",
    ["DWORD"] = "Long",
    ["char"] = "Long",
    ["unsigned char"] = "Long",
    ["LPCWSTR"] = "Long",
    ["LPUINT"] = "OLE_HANDLE",
    ["void *"] = "OLE_HANDLE",
    ["sqlite3_callback"] = "OLE_HANDLE",
    ["va_list"] = "OLE_HANDLE",
    [""] = "OLE_COLOR",
}

local function tovbtype(ptype)
    local ret = mapvbtype[ptype]
    if not ret and ptype:sub(-1) == "*" or ptype:sub(-1) == ")" then
        ret = "OLE_HANDLE"
    end
    if not ret then
        ret = mapvbtype[""]
        print(string.format("' Warning: unknown C/C++ type %s, defaulting to %s", ptype, ret))
        io.stderr:write(string.format("   Warning: unknown C/C++ type %s, defaulting to %s\n", ptype, ret))
    end
    return ret    
end

local def_parser = re.compile("{| ((%s* '"..DEBUG_API_PREFIX.."' { [_%w]+ }) / (!%nl .)* %nl)+ |}")
local c_parser = re.compile([[
    top         <- {| (<decl> / <skipline>)+ |}
    decl        <- {| 'SQLITE_API' s {:ftype: (!(s 'SQLITE_STDCALL') ![=] .)+ :} s 'SQLITE_STDCALL' s ']].. DEBUG_API_PREFIX ..[[' {:fname: [_%w]+ :}
                    s '(' s <params>? s ')' s '{' |}
    params      <- <param> (s ',' <param>)*
    param       <- {| <part>+ |} -> param
    part        <- (s { [_%w]+ } / s { '*' } / s { '(*' } <part>+ s { ')' } / s '(' [^)]+ ')')
    skipline    <- (!%nl .)* %nl
    s           <- (('/*' (!'*/' .)* '*/') / [%nl%s])*
]], {
    param = function(t)
        local ret = { pname = t[#t] }
        if t[#t] == ')' then
            ret.pname = t[#t - 1]
            t[#t - 1] = ')()'
        end
        t[#t] = nil
        ret.ptype = table.concat(t, ' ')
        return ret
    end
})

local map_reserved = {
    ["open"] = true,
    ["close"] = true,
    ["type"] = true,
}

local function main(def_file, mod_name)
    local exports = {}
    local declares = {}
    local impl = {}

    -- load exported functions from debug library .def file
    for _, v in ipairs(def_parser:match(readfile(def_file))) do
        exports[v] = true
    end
    for _, v in ipairs(c_parser:match(io.read("*all"))) do
        if exports[v.fname] then
            local params = { }
            local args = { }
            for i = 1, #v do
                if v[i].ptype and v[i].ptype ~= "" then
                    -- cannot use reserved VB6 keyword for param name
                    if map_reserved[v[i].pname:lower()] then
                        v[i].pname = v[i].pname.."_"
                    end
                    params[#params + 1] = string.format("ByVal %s As %s", v[i].pname, tovbtype(v[i].ptype))
                    args[#args + 1] = v[i].pname
                end
            end
            params = table.concat(params, ", ")
            args = table.concat(args, ", ")
            local ftype = tovbtype(v.ftype)
            local fname = VB_API_PREFIX..v.fname
            local apifname = DEBUG_API_PREFIX..v.fname
            if map_reserved[fname:lower()] then
                fname = fname.."_"
            end
            declares[#declares + 1] = (string.format("Private Declare Function %s Lib \"%s\" (%s) As %s",
                apifname, DEBUG_DLL_FILE, params, ftype))
            impl[#impl + 1] = string.format([[
Public Function %s(%s) As %s
    %s = %s(%s)
End Function]], fname, params, ftype, fname, apifname, args)
            -- prevent duplicates from conditional compilation in C/C++ source file
            exports[v.fname] = nil
        end
    end
    -- generate .bas file
    print(string.format("Attribute VB_Name = \"%s\"", mod_name))
    print"'"
    print(string.format("' Auto-generated by extract.lua at %s", os.date()))
    print"' Please do not edit manually!"
    print"'"
    print"Option Explicit"
    print"DefObj A-Z"
    print""
    print(table.concat(declares, "\n"))
    print""
    print(table.concat(impl, "\n\n"))
end

main(#arg > 0 and arg[1] or DEFAULT_ARG1, #arg > 1 and arg[2] or DEFAULT_ARG2)
